// Code generated by goa v3.16.2, DO NOT EDIT.
//
// folder HTTP client encoders and decoders
//
// Command:
// $ goa gen mai.today/api/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	goahttp "goa.design/goa/v3/http"
	folder "mai.today/api/gen/folder"
)

// BuildReceiveCreateFolderRequest instantiates a HTTP request object with
// method and path set to call the "folder" service "receiveCreateFolder"
// endpoint
func (c *Client) BuildReceiveCreateFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		channel string
	)
	{
		p, ok := v.(*folder.ReceiveCreateFolderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "receiveCreateFolder", "*folder.ReceiveCreateFolderPayload", v)
		}
		channel = p.Channel
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReceiveCreateFolderFolderPath(channel)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "receiveCreateFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReceiveCreateFolderRequest returns an encoder for requests sent to the
// folder receiveCreateFolder server.
func EncodeReceiveCreateFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.ReceiveCreateFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "receiveCreateFolder", "*folder.ReceiveCreateFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeReceiveCreateFolderResponse returns a decoder for responses returned
// by the folder receiveCreateFolder endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeReceiveCreateFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusSwitchingProtocols:
			res := NewReceiveCreateFolderCreateFolderResultSwitchingProtocols()
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "receiveCreateFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateFolderRequest instantiates a HTTP request object with method and
// path set to call the "folder" service "CreateFolder" endpoint
func (c *Client) BuildCreateFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateFolderFolderPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "CreateFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateFolderRequest returns an encoder for requests sent to the folder
// CreateFolder server.
func EncodeCreateFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.CreateFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "CreateFolder", "*folder.CreateFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreateFolderRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("folder", "CreateFolder", err)
		}
		return nil
	}
}

// DecodeCreateFolderResponse returns a decoder for responses returned by the
// folder CreateFolder endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCreateFolderResponse may return the following errors:
//   - "invalid token" (type *goa.ServiceError): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateFolderOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "CreateFolder", err)
			}
			err = ValidateCreateFolderOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "CreateFolder", err)
			}
			res := NewCreateFolderResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body CreateFolderInvalidTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "CreateFolder", err)
			}
			err = ValidateCreateFolderInvalidTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "CreateFolder", err)
			}
			return nil, NewCreateFolderInvalidToken(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "CreateFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildReceiveDeleteFolderRequest instantiates a HTTP request object with
// method and path set to call the "folder" service "receiveDeleteFolder"
// endpoint
func (c *Client) BuildReceiveDeleteFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		channel string
	)
	{
		p, ok := v.(*folder.ReceiveDeleteFolderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "receiveDeleteFolder", "*folder.ReceiveDeleteFolderPayload", v)
		}
		channel = p.Channel
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReceiveDeleteFolderFolderPath(channel)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "receiveDeleteFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReceiveDeleteFolderRequest returns an encoder for requests sent to the
// folder receiveDeleteFolder server.
func EncodeReceiveDeleteFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.ReceiveDeleteFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "receiveDeleteFolder", "*folder.ReceiveDeleteFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeReceiveDeleteFolderResponse returns a decoder for responses returned
// by the folder receiveDeleteFolder endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeReceiveDeleteFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusSwitchingProtocols:
			res := NewReceiveDeleteFolderDeleteFolderResultSwitchingProtocols()
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "receiveDeleteFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteFolderRequest instantiates a HTTP request object with method and
// path set to call the "folder" service "DeleteFolder" endpoint
func (c *Client) BuildDeleteFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		folderID string
	)
	{
		p, ok := v.(*folder.DeleteFolderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "DeleteFolder", "*folder.DeleteFolderPayload", v)
		}
		folderID = p.FolderID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteFolderFolderPath(folderID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "DeleteFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteFolderRequest returns an encoder for requests sent to the folder
// DeleteFolder server.
func EncodeDeleteFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.DeleteFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "DeleteFolder", "*folder.DeleteFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDeleteFolderResponse returns a decoder for responses returned by the
// folder DeleteFolder endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDeleteFolderResponse may return the following errors:
//   - "invalid token" (type *goa.ServiceError): http.StatusUnauthorized
//   - error: internal error
func DecodeDeleteFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DeleteFolderOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "DeleteFolder", err)
			}
			err = ValidateDeleteFolderOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "DeleteFolder", err)
			}
			res := NewDeleteFolderResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body DeleteFolderInvalidTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "DeleteFolder", err)
			}
			err = ValidateDeleteFolderInvalidTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "DeleteFolder", err)
			}
			return nil, NewDeleteFolderInvalidToken(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "DeleteFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildReceiveUpdateFolderRequest instantiates a HTTP request object with
// method and path set to call the "folder" service "receiveUpdateFolder"
// endpoint
func (c *Client) BuildReceiveUpdateFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		channel string
	)
	{
		p, ok := v.(*folder.ReceiveUpdateFolderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "receiveUpdateFolder", "*folder.ReceiveUpdateFolderPayload", v)
		}
		channel = p.Channel
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReceiveUpdateFolderFolderPath(channel)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "receiveUpdateFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReceiveUpdateFolderRequest returns an encoder for requests sent to the
// folder receiveUpdateFolder server.
func EncodeReceiveUpdateFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.ReceiveUpdateFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "receiveUpdateFolder", "*folder.ReceiveUpdateFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeReceiveUpdateFolderResponse returns a decoder for responses returned
// by the folder receiveUpdateFolder endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeReceiveUpdateFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusSwitchingProtocols:
			res := NewReceiveUpdateFolderUpdateFolderResultSwitchingProtocols()
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "receiveUpdateFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateFolderRequest instantiates a HTTP request object with method and
// path set to call the "folder" service "UpdateFolder" endpoint
func (c *Client) BuildUpdateFolderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		folderID string
	)
	{
		p, ok := v.(*folder.UpdateFolderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "UpdateFolder", "*folder.UpdateFolderPayload", v)
		}
		folderID = p.FolderID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateFolderFolderPath(folderID)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "UpdateFolder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateFolderRequest returns an encoder for requests sent to the folder
// UpdateFolder server.
func EncodeUpdateFolderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.UpdateFolderPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "UpdateFolder", "*folder.UpdateFolderPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateFolderRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("folder", "UpdateFolder", err)
		}
		return nil
	}
}

// DecodeUpdateFolderResponse returns a decoder for responses returned by the
// folder UpdateFolder endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateFolderResponse may return the following errors:
//   - "invalid token" (type *goa.ServiceError): http.StatusUnauthorized
//   - error: internal error
func DecodeUpdateFolderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateFolderOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "UpdateFolder", err)
			}
			err = ValidateUpdateFolderOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "UpdateFolder", err)
			}
			res := NewUpdateFolderResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UpdateFolderInvalidTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "UpdateFolder", err)
			}
			err = ValidateUpdateFolderInvalidTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "UpdateFolder", err)
			}
			return nil, NewUpdateFolderInvalidToken(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "UpdateFolder", resp.StatusCode, string(body))
		}
	}
}

// BuildReceiveListFoldersRequest instantiates a HTTP request object with
// method and path set to call the "folder" service "receiveListFolders"
// endpoint
func (c *Client) BuildReceiveListFoldersRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		channel string
	)
	{
		p, ok := v.(*folder.ReceiveListFoldersPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("folder", "receiveListFolders", "*folder.ReceiveListFoldersPayload", v)
		}
		channel = p.Channel
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReceiveListFoldersFolderPath(channel)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "receiveListFolders", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReceiveListFoldersRequest returns an encoder for requests sent to the
// folder receiveListFolders server.
func EncodeReceiveListFoldersRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.ReceiveListFoldersPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "receiveListFolders", "*folder.ReceiveListFoldersPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeReceiveListFoldersResponse returns a decoder for responses returned by
// the folder receiveListFolders endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeReceiveListFoldersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusSwitchingProtocols:
			res := NewReceiveListFoldersListFoldersResultSwitchingProtocols()
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "receiveListFolders", resp.StatusCode, string(body))
		}
	}
}

// BuildListFoldersRequest instantiates a HTTP request object with method and
// path set to call the "folder" service "ListFolders" endpoint
func (c *Client) BuildListFoldersRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListFoldersFolderPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("folder", "ListFolders", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListFoldersRequest returns an encoder for requests sent to the folder
// ListFolders server.
func EncodeListFoldersRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*folder.ListFoldersPayload)
		if !ok {
			return goahttp.ErrInvalidType("folder", "ListFolders", "*folder.ListFoldersPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListFoldersResponse returns a decoder for responses returned by the
// folder ListFolders endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeListFoldersResponse may return the following errors:
//   - "invalid token" (type *goa.ServiceError): http.StatusUnauthorized
//   - error: internal error
func DecodeListFoldersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListFoldersOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "ListFolders", err)
			}
			err = ValidateListFoldersOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "ListFolders", err)
			}
			res := NewListFoldersResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ListFoldersInvalidTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("folder", "ListFolders", err)
			}
			err = ValidateListFoldersInvalidTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("folder", "ListFolders", err)
			}
			return nil, NewListFoldersInvalidToken(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("folder", "ListFolders", resp.StatusCode, string(body))
		}
	}
}

// marshalFolderFolderToFolderRequestBody builds a value of type
// *FolderRequestBody from a value of type *folder.Folder.
func marshalFolderFolderToFolderRequestBody(v *folder.Folder) *FolderRequestBody {
	res := &FolderRequestBody{
		FolderID:  v.FolderID,
		BaseID:    v.BaseID,
		ParentID:  v.ParentID,
		Position:  v.Position,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		Type:      v.Type,
	}
	if v.Data != nil {
		res.Data = marshalFolderFolderDataToFolderDataRequestBody(v.Data)
	}

	return res
}

// marshalFolderFolderDataToFolderDataRequestBody builds a value of type
// *FolderDataRequestBody from a value of type *folder.FolderData.
func marshalFolderFolderDataToFolderDataRequestBody(v *folder.FolderData) *FolderDataRequestBody {
	res := &FolderDataRequestBody{
		Color: v.Color,
		Name:  v.Name,
	}

	return res
}

// marshalFolderRequestBodyToFolderFolder builds a value of type *folder.Folder
// from a value of type *FolderRequestBody.
func marshalFolderRequestBodyToFolderFolder(v *FolderRequestBody) *folder.Folder {
	res := &folder.Folder{
		FolderID:  v.FolderID,
		BaseID:    v.BaseID,
		ParentID:  v.ParentID,
		Position:  v.Position,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		Type:      v.Type,
	}
	if v.Data != nil {
		res.Data = marshalFolderDataRequestBodyToFolderFolderData(v.Data)
	}

	return res
}

// marshalFolderDataRequestBodyToFolderFolderData builds a value of type
// *folder.FolderData from a value of type *FolderDataRequestBody.
func marshalFolderDataRequestBodyToFolderFolderData(v *FolderDataRequestBody) *folder.FolderData {
	res := &folder.FolderData{
		Color: v.Color,
		Name:  v.Name,
	}

	return res
}

// unmarshalCommandResponseBodyToFolderCommand builds a value of type
// *folder.Command from a value of type *CommandResponseBody.
func unmarshalCommandResponseBodyToFolderCommand(v *CommandResponseBody) *folder.Command {
	res := &folder.Command{
		Type: *v.Type,
	}

	return res
}

// unmarshalCreatefolderresultdataResponseBodyToFolderCreatefolderresultdata
// builds a value of type *folder.Createfolderresultdata from a value of type
// *CreatefolderresultdataResponseBody.
func unmarshalCreatefolderresultdataResponseBodyToFolderCreatefolderresultdata(v *CreatefolderresultdataResponseBody) *folder.Createfolderresultdata {
	res := &folder.Createfolderresultdata{
		FolderID:  *v.FolderID,
		BaseID:    *v.BaseID,
		ParentID:  *v.ParentID,
		Position:  v.Position,
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
		Type:      *v.Type,
	}
	res.Data = unmarshalFolderDataResponseBodyToFolderFolderData(v.Data)

	return res
}

// unmarshalFolderDataResponseBodyToFolderFolderData builds a value of type
// *folder.FolderData from a value of type *FolderDataResponseBody.
func unmarshalFolderDataResponseBodyToFolderFolderData(v *FolderDataResponseBody) *folder.FolderData {
	res := &folder.FolderData{
		Color: *v.Color,
		Name:  *v.Name,
	}

	return res
}
